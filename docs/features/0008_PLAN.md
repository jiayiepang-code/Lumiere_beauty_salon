## Admin Staff Leave Management – Technical Plan

### Context

Implement an Admin-facing interface and backend workflow to manage **staff leave requests**, focused on:

- A dedicated **"Leave Requests"** view in the Admin Portal.
- Showing all **pending** leave requests in a table with key metadata.
- Providing **Approve** and **Reject** actions.
- On **approval**, updating the `staff_schedule` table for every date in the leave range to mark the staff member as on leave for the full day (10:00–22:00).
- On **rejection**, only updating the `leave_requests` status (no `staff_schedule` changes).
- **Conflict Detection**: Before approving leave, the system checks for existing confirmed bookings for the staff member during the leave period and warns the admin.
- **Customer Notification**: When leave is approved despite conflicts, affected customers are automatically notified via email about their booking status (cancellation, reassignment, or rescheduling needed).

The plan assumes an existing `Staff_Schedule` (or `staff_schedule`) table and `Staff` records keyed by `staff_email` (per existing plans), and introduces or relies on a `leave_requests` table that stores requests with start/end dates, type, duration, and status.

---

### Files to Create or Modify

#### 1. Admin UI – Leave Requests Listing

- **New Admin View**

  - **File**: `admin/leave_requests/index.php`.
  - **Responsibility**: Provide a dedicated **“Leave Requests”** page in the Admin portal and render the **pending leave requests** table with actions.

- **Shared Layout / Includes**

  - **Files**: `admin/includes/header.php`, `admin/includes/sidebar.php`, `admin/includes/footer.php`, `admin/includes/auth_check.php`.
  - **Usage**:
    - Ensure **admin authentication** via an existing `requireAdminAuth()` or equivalent.
    - Integrate the new “Leave Requests” navigation item (in sidebar) clearly under the Management section alongside Staff and Services.

- **Client-Side Logic**
  - **New JS file**: `admin/leave_requests/leave_requests.js`.
  - **Responsibilities**:
    - Fetch the list of **pending** leave requests from a new Admin API endpoint (see backend section).
    - Render the table rows dynamically if the view uses an API-driven table, or enhance a PHP-rendered table (e.g., attach click handlers to Approve/Reject buttons).
    - Handle **Approve** and **Reject** button clicks:
      - **Conflict Check**: Before showing approval confirmation, check for conflicting bookings via `check_conflicts.php` API endpoint.
      - **Warning Dialog**: If conflicts exist, display a detailed warning dialog (using SweetAlert2) showing:
        - Number of conflicting bookings.
        - Customer names, booking dates, times, and services for each conflict.
        - Allow admin to proceed with approval or cancel.
      - Perform an **asynchronous request** (XHR/fetch) to the backend with:
        - `request_id` (primary key of `leave_requests`).
        - `action` set to either `approve` or `reject`.
      - On success, **remove the row** from the pending list or update the status column without a full page reload.
      - Display user feedback (toast/alert) for success/failure, including conflict count and email notification status.

#### 2. Admin API – Leave Request Management

- **New API Endpoint (Admin)**

  - **File**: `api/admin/leave_requests/list.php` (listing) or a consolidated file like `api/admin/leave_requests/index.php` with different actions (list, approve, reject).
  - **Responsibilities**:
    - **List endpoint**:
      - Return all leave requests where `status` equals `pending`.
      - Join with the `Staff` table (or equivalent) to fetch **staff name** fields, and ensure `staff_email` (or staff primary key) is available to the frontend.
      - Return a JSON structure including:
        - `request_id`
        - `staff_email`
        - `staff_name` (concatenation of first/last name)
        - `leave_type`
        - `start_date`
        - `end_date`
        - `duration_type` (full day / half day)
        - `reason`
        - `created_at`
        - `status`
    - Use existing DB connection utilities in `config/db_connect.php` (for example, `getDBConnection()`).
    - Use **prepared statements** and escape output at the PHP-to-HTML boundary.

- **New API Endpoint – Conflict Check**

  - **File**: `api/admin/leave_requests/check_conflicts.php`.
  - **Inputs**:
    - HTTP method: **GET** or **POST**.
    - Parameters:
      - `request_id` – identifier of the leave request to check.
  - **Responsibilities**:
    - Validate admin authentication.
    - Load the leave request and extract `staff_email`, `start_date`, `end_date`.
    - Query `Booking` and `Booking_Service` tables to find:
      - All bookings with `status` in `('confirmed', 'completed')` for the staff member.
      - Bookings where the service date falls within the leave date range.
    - Return JSON response with:
      - `has_conflicts`: boolean indicating if conflicts exist.
      - `conflicting_bookings`: array of booking details (customer name, date, time, services, booking ID).

- **New API Endpoint – Approve/Reject Action**
  - **File**: `api/admin/leave_requests/update.php` (or re-use `api/admin/leave_requests/index.php` with a POST action).
  - **Inputs**:
    - HTTP method: **POST**.
    - Parameters:
      - `request_id` – identifier of the leave request to operate on.
      - `action` – string, must be exactly `approve` or `reject`.
  - **Responsibilities**:
    - Validate admin authentication and authorization:
      - Re-use existing admin auth pattern (e.g., check session or re-use `auth_check.php` style checks for API).
    - Load the target leave request by `request_id`:
      - Ensure the record exists and currently has `status = 'pending'`.
      - Fetch associated fields:
        - `staff_email` (or staff foreign key).
        - `start_date`, `end_date`.
        - `duration_type` (full/half day, even if v1 only uses full day).
        - `leave_type` and `reason` for logging/auditing if needed.
    - Branch by action:
      - For **reject**:
        - Update `leave_requests.status` to `rejected`.
        - Optionally store `processed_at` and `processed_by` (admin email/ID) if audit columns exist.
        - Do **not** change `staff_schedule`.
      - For **approve**:
        - **Conflict Detection**: Before proceeding, check for conflicting bookings (same logic as `check_conflicts.php`).
        - **Booking Marking**: If conflicts exist:
          - Update conflicting bookings' `remarks` field to indicate "Staff on leave - needs rescheduling/reassignment".
          - Change booking `status` from `'confirmed'` to `'needs_reschedule'` (if applicable).
        - **Email Notifications**: For each conflicting booking:
          - Send email notification to customer via `EmailService->sendBookingConflictEmail()`.
          - Track success/failure counts for response.
        - Wrap the `leave_requests` update, `staff_schedule` operations, and booking updates in a **database transaction**:
          - Step 1: Update `leave_requests.status` to `approved` and optionally track `processed_at` and `processed_by`.
          - Step 2: For each date from `start_date` through `end_date` inclusive, apply a **create-or-update** operation on `staff_schedule` to mark the staff member as on leave.
          - Step 3: Update conflicting bookings (remarks and status).
        - Commit the transaction; on any error, **roll back** and return an error response to the frontend.
        - Return JSON response including:
          - `status`: `'approved'`.
          - `request_id`.
          - `conflict_count`: number of conflicting bookings found.
          - `emails_sent`: number of emails successfully sent.
          - `emails_failed`: number of emails that failed to send.

#### 3. Email Service Extension

- **Email Service**
  - **File**: `includes/EmailService.php`.
  - **New Method**: `sendBookingConflictEmail($customerEmail, $customerName, $bookingDetails, $staffName, $leaveDates)`.
  - **Responsibilities**:
    - Send HTML and plain text email notifications to customers when their booking conflicts with approved staff leave.
    - Email includes:
      - Customer name and booking details (date, time, services).
      - Staff member name and leave date range.
      - Information that the booking needs to be rescheduled, reassigned, or cancelled.
      - Salon contact information (phone, address, location) from config constants.
    - Uses existing PHPMailer integration and email templates pattern.
    - Returns boolean indicating success/failure.

#### 4. Database Layer / Utilities

- **Existing Connection Utilities**

  - **File**: `config/db_connect.php`.
  - **Usage**:
    - Use the central DB connection helper (e.g., `getDBConnection()`) inside the new API endpoints.
    - Ensure that the connection is configured to support **transactions** (e.g., `autocommit` control if using MySQLi).

- **Indexing & Performance**
  - **File**: `admin/includes/database_indexes.sql`.
  - **Potential additions**:
    - Confirm there are indexes on `staff_schedule` for:
      - `staff_email`
      - `work_date`
      - Composite key `(staff_email, work_date)` to support the "insert or update by staff and date" pattern.
    - Confirm `leave_requests` has:
      - An index on `status` (for fast retrieval of pending requests).
      - An index on `staff_email` (for related queries, if not already present).
    - Confirm `Booking` table has indexes for conflict detection:
      - `staff_email` (or staff foreign key).
      - `service_date` (or booking date field).
      - `status` (for filtering confirmed/completed bookings).

---

### Data Model and Schema Assumptions

- **leave_requests Table (actual structure)**

  - Core columns:
    - `id` (primary key, used as `request_id`).
    - `staff_email` (or staff foreign key) – reference to the staff member requesting leave.
    - `leave_type` – type/category of leave (e.g., vacation, sick, unpaid).
    - `start_date` and `end_date` – inclusive date range for the leave.
    - `half_day` (TINYINT) – indicates if the leave is half day (1) or full day (0). The UI derives "Full Day" or "Half Day" labels from this field.
    - `reason` – text description provided by staff.
    - `status` – possible values: `pending`, `approved`, `rejected`.
    - `created_at` – timestamp when the request was submitted.
    - Optional audit fields: `processed_at`, `processed_by` for admin actions.
  - **Note**: The actual implementation uses `half_day` (TINYINT) instead of `duration_type` (ENUM). The API endpoints derive `duration_type` and `duration_label` from `half_day` for frontend consumption.

- **staff_schedule / Staff_Schedule Table (schema from existing work)**

  - Core columns:
    - `staff_email` – identifies the staff member.
    - `work_date` – the date for which the schedule applies.
    - `start_time` and `end_time` – working time range.
    - `status` – includes at least one value representing `leave` (in addition to regular working/available statuses such as `available` or `booked`).
  - Constraints:
    - The combination of `staff_email` and `work_date` must be **unique** (primary key or unique index) to support the "insert or update" pattern.

- **Booking and Booking_Service Tables (for conflict detection)**
  - Used to detect existing bookings that conflict with approved leave.
  - **Booking** table contains:
    - `booking_id` (primary key).
    - `customer_email` and customer information.
    - `status` – values include `'confirmed'`, `'completed'`, `'needs_reschedule'`, etc.
    - `remarks` – text field for admin notes (updated when conflicts are detected).
  - **Booking_Service** table contains:
    - `booking_id` (foreign key to Booking).
    - `staff_email` – identifies the assigned staff member.
    - `service_date` – the date of the service.
    - `service_time` – the time of the service.
    - Service details (service name, duration, etc.).
  - Conflict detection queries join these tables to find bookings where `staff_email` matches and `service_date` falls within the leave period.

---

### Admin UI Requirements (Leave Requests View)

#### Table Layout and Columns

- **Source**: Pending leave requests fetched from the new Admin API or rendered directly via PHP with server-side queries.
- **Columns to display**:
  - **Staff Name**:
    - Derived from the `Staff` table using `staff_email` (join first/last name).
    - Shown as full name in the table.
  - **Leave Type**:
    - Short label, as stored in `leave_requests.leave_type`.
  - **Date Range**:
    - Concatenation of `start_date` and `end_date` as “Start Date – End Date”.
    - If start and end are identical, show a single date.
  - **Duration**:
    - “Full Day” or “Half Day” from `duration_type`.
  - **Reason**:
    - Table cell shows a **shortened version** of the reason (e.g., truncated to a fixed number of characters).
    - Full reason available via **tooltip, hover text, or expandable row** so admins can inspect the full message without cluttering the table.
  - **Submission Date/Time**:
    - Use `created_at`, formatted in a readable way (e.g., local date and time).
  - **Action Buttons**:
    - Two buttons per row:
      - Approve.
      - Reject.
    - Buttons must be clearly styled (e.g., green/primary for approve, red/secondary for reject) and disabled while a request is in-flight.

#### User Interaction Flow

- When the page loads:

  - Fetch pending leave requests.
  - Populate the table (empty state if no data, with a message like “No pending leave requests.”).

- When **Approve** is clicked:

  - **Pre-approval Conflict Check**: First, call `check_conflicts.php` to detect any conflicting bookings.
  - **Warning Dialog**: If conflicts exist:
    - Display a SweetAlert2 warning dialog with:
      - Title: "⚠️ Conflicting Bookings Detected"
      - List of conflicting bookings (customer name, date, time, services).
      - Message explaining that customers will be notified and bookings will be marked for rescheduling.
      - Options: "Proceed Anyway" or "Cancel".
    - If admin cancels, abort the approval process.
  - **Confirmation**: If no conflicts or admin proceeds, show standard confirmation dialog.
  - Send an asynchronous POST to the update endpoint with `request_id` and `action = 'approve'`.
  - While waiting:
    - Disable the action buttons for that row.
    - Optionally show a loading indicator.
  - On success:
    - Remove the row from the table or update its status to approved and move it out of the "Pending" view.
    - Show a success message, including:
      - Confirmation that leave was approved.
      - Number of customers notified (if conflicts existed).
      - Warning if any emails failed to send.
  - On failure:
    - Re-enable the buttons.
    - Show an error message; do not change UI state.

- When **Reject** is clicked:
  - Similar flow to approve:
    - Confirm action.
    - POST with `action = 'reject'`.
    - Update UI on success as above (remove or change status).

---

### Backend Logic – Approve / Reject Workflow

#### Common Validation Steps

For both approval and rejection actions, the server-side handler should:

1. **Authenticate Admin**

   - Ensure the request is from an authenticated admin session, re-using existing admin authentication utilities.

2. **Validate Input**

   - Read `request_id` from POST data and ensure it is a valid integer.
   - Read `action` and ensure it is exactly `approve` or `reject`.
   - Reject the request with an error response if validation fails.

3. **Load Leave Request**
   - Select the leave request record by `id = request_id`.
   - Ensure the record exists and is currently `status = 'pending'`.
   - Extract:
     - `staff_email` (or staff identifier).
     - `start_date`.
     - `end_date`.
     - `duration_type`.
     - Other metadata as needed.
   - If not found or status is not `pending`, return an error (e.g., “Request not found or already processed”) without making changes.

#### Reject Action – Server-Side Steps

When `action = 'reject'`:

1. **Update leave_requests**

   - Set the status field to `rejected` for the given `request_id`.
   - Optionally set `processed_at` to the current timestamp and `processed_by` to the admin’s identifier.

2. **No staff_schedule Changes**

   - Do not insert or alter any records in `staff_schedule`.

3. **Return Response**
   - Return a structured JSON response indicating success and echoing updated status so the frontend can adjust the UI.

#### Approve Action – Server-Side Steps

When `action = 'approve'`:

1. **Conflict Detection**

   - Query `Booking` and `Booking_Service` tables to find all bookings where:
     - `staff_email` matches the leave request's staff member.
     - `service_date` (or equivalent date field) falls within the leave date range (`start_date` to `end_date` inclusive).
     - `status` is `'confirmed'` or `'completed'`.
   - Store the list of conflicting bookings for later processing.

2. **Start Transaction**

   - Begin a database transaction to ensure that updating the `leave_requests` record, applying all `staff_schedule` changes, updating conflicting bookings, and sending email notifications occur atomically (where possible).

3. **Update leave_requests**

   - Set the status field to `approved` for the given `request_id`.
   - Optionally set `processed_at` and `processed_by` as with rejection.

4. **Mark Conflicting Bookings**

   - For each conflicting booking found:
     - Update the `remarks` field to append: "Staff on leave - needs rescheduling/reassignment" (or similar message).
     - If booking status is `'confirmed'`, change it to `'needs_reschedule'` to prevent further processing.
     - Note: This marking helps admins identify which bookings need manual intervention.

5. **Iterate Over Date Range**

   - Compute a loop variable representing the **current date**, initialized to `start_date`.
   - Repeat until the current date exceeds `end_date`:
     - For each date in the inclusive range:
       - Determine the desired schedule state:
         - For this feature, always mark the staff member as on **leave** for the entire day from 10:00 to 22:00.
         - The **duration_type** column can be used for future extensions (e.g., half-day logic), but in the current scope the schedule is fully blocked for the specified date.
       - Perform a database operation that either:
         - Inserts a new row in `staff_schedule` with:
           - `staff_email` set to the requesting staff member.
           - `work_date` set to the current date in the loop.
           - `start_time` set to 10:00:00.
           - `end_time` set to 22:00:00.
           - `status` set to `leave`.
         - Or, if a row with the same `staff_email` and `work_date` already exists (based on a unique constraint or primary key):
           - Updates the existing row to set `status` to `leave` (and adjust times if necessary).
       - Move to the next date by adding one day to the loop variable.

6. **Commit Transaction**

   - If all database operations succeed:
     - Commit the transaction so the updated `leave_requests` status, all `staff_schedule` entries, and booking updates are saved.

7. **Send Email Notifications** (After Transaction Commit)

   - For each conflicting booking:
     - Extract customer email and name from the booking record.
     - Call `EmailService->sendBookingConflictEmail()` with:
       - Customer email and name.
       - Booking details (date, time, services).
       - Staff member name.
       - Leave date range.
     - Track success/failure counts.
   - Note: Email sending occurs after transaction commit to avoid rollback if email fails (emails are non-critical for data integrity).

8. **Return Response**

   - On success, send a JSON response containing:
     - The final status (`approved`).
     - The `request_id`.
     - `conflict_count`: number of conflicting bookings found.
     - `emails_sent`: number of emails successfully sent.
     - `emails_failed`: number of emails that failed to send.
     - Optionally, the affected date range for UI or logs.

9. **Error Handling**

   - If any database operation fails:
     - Roll back the transaction to revert all changes.
     - Return an error response to the frontend with a safe, user-friendly message.
   - If email sending fails (after successful database commit):
     - Log the error but still return success (with `emails_failed` count).
     - The admin can manually notify customers if needed.

---

### Algorithm Details (Described, No Code)

#### Date Range Iteration Algorithm

1. Read the request’s `start_date` and `end_date` from the database.
2. Convert both dates into a date object type supported by the language or database driver.
3. Initialize a variable `current_date` to `start_date`.
4. While `current_date` is less than or equal to `end_date`:
   - Use `current_date` as the `work_date` for the schedule row.
   - Perform the single-record “insert or update” schedule operation for that date.
   - Increment `current_date` by one day using a date-add function.
5. After the loop finishes, all dates in the range are covered.

#### Insert-or-Update Schedule Operation (Conceptual)

1. Determine the unique key for a schedule row: combination of `staff_email` and `work_date`.
2. Attempt to write a row for this staff member and date with:
   - Start time 10:00.
   - End time 22:00.
   - Status `leave`.
3. If the database reports a constraint conflict because a row already exists:
   - Execute an update that sets the status of the existing row to `leave` and, if necessary, aligns the start/end time to the leave period.
4. Ensure this operation is part of the open transaction for the approval.

---

### Security and Error Handling

- **Security**

  - All admin endpoints must:
    - Check authentication and only allow logged-in admins to list or update leave requests.
    - Use prepared statements or safe query builders for all database operations.
  - Inputs from the client (`request_id`, `action`) must be strictly validated and not trusted blindly.

- **Error Handling**

  - For API errors:
    - Return structured JSON with an `error` field and relevant message.
    - Use safe, non-sensitive messages for end users; log full details on the server using existing logging utilities or `error_log`.
  - For UI:
    - Display concise error messages when approvals or rejections fail.
    - Do not update the table row unless the backend confirms success.

- **Idempotency and Concurrency**
  - Ensure that only requests in `pending` state can be approved or rejected:
    - Re-check the status at the moment of processing.
  - Handle repeated clicks or duplicated requests by:
    - Returning a clear error when the request is already processed.
    - Frontend should refresh or remove such rows from the pending list.

---

### Integration With Existing Calendar/Master Schedule

- Ensure that the updated `staff_schedule` rows with `status = 'leave'` are:
  - Interpreted by existing calendar or booking logic as **unavailable** time.
  - Displayed in the Master Calendar (if applicable) in a distinct style (e.g., shaded or colored blocks).
- Confirm that any booking creation logic checks `staff_schedule` status so that approved leave days prevent double-bookings.

---

### Summary of Key Behaviors

- The Admin sees a **"Leave Requests"** view listing all **pending** leave requests with:
  - Staff Name, Leave Type, Date Range, Duration (Full/Half Day), Reason (shortened + tooltip), Submission Date/Time, and Approve/Reject buttons.
- Clicking **Approve**:
  - **Conflict Check**: System checks for existing confirmed/completed bookings for the staff member during the leave period.
  - **Warning Dialog**: If conflicts exist, admin sees a detailed warning with booking information and can choose to proceed or cancel.
  - **Approval Process**:
    - Sets `leave_requests.status` to `approved`.
    - For each date in the request's range, marks the staff member as on leave for **10:00–22:00** in `staff_schedule`, inserting or updating as needed.
    - **Booking Marking**: Updates conflicting bookings' `remarks` field and changes status to `'needs_reschedule'` if applicable.
    - **Customer Notification**: Automatically sends email notifications to affected customers informing them of the conflict and need for rescheduling/reassignment.
  - **Success Feedback**: Admin receives confirmation including number of conflicts detected and email notification status.
- Clicking **Reject**:
  - Sets `leave_requests.status` to `rejected`.
  - Leaves `staff_schedule` unchanged.
  - No conflict checking or customer notifications are performed.

### Conflict Detection and Customer Notification

#### Problem Statement

When a staff member's leave request is approved, existing confirmed bookings for that staff member during the leave period create a conflict. These bookings remain visible in the master schedule and could lead to:

- Double-booking scenarios.
- Customer confusion when they arrive for appointments.
- Operational inefficiencies.

#### Solution Approach

1. **Proactive Conflict Detection**:

   - Before approval, the system queries for existing bookings that overlap with the leave period.
   - Admin is warned with detailed booking information before confirming approval.

2. **Booking Marking**:

   - Conflicting bookings are marked in the database (`remarks` field updated, status changed to `'needs_reschedule'`).
   - This allows admins to easily identify and manage affected bookings.

3. **Automatic Customer Notification**:

   - When leave is approved despite conflicts, customers receive email notifications.
   - Emails include booking details, staff leave information, and guidance on next steps (reschedule, reassign, or cancel).

4. **Admin Control**:
   - Admin can see conflicts before approving and choose to proceed or cancel.
   - Admin receives feedback on how many customers were notified and if any emails failed.

#### Technical Implementation

- **Conflict Detection Query**: Joins `Booking` and `Booking_Service` tables to find bookings where:

  - Staff email matches the leave request.
  - Service date falls within leave date range.
  - Status is `'confirmed'` or `'completed'`.

- **Email Service Extension**: New method `sendBookingConflictEmail()` in `EmailService.php`:

  - Uses existing PHPMailer integration.
  - Includes HTML and plain text templates.
  - Provides booking details, staff information, and salon contact info.

- **Transaction Safety**: Database operations (leave approval, schedule updates, booking marking) are wrapped in a transaction. Email sending occurs after commit to avoid rollback on email failures.

#### User Experience Flow

1. Admin clicks "Approve" on a leave request.
2. Frontend calls `check_conflicts.php` to detect conflicts.
3. If conflicts exist, admin sees warning dialog with booking details.
4. Admin can proceed or cancel.
5. If proceeding, approval API is called.
6. Backend marks bookings and sends emails.
7. Admin sees success message with conflict/email status.
